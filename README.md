# JVM구조, SevletContainer, SpringContainer, IoC, DI에 대해서

> Inversion of Controll, Dependency Injection 을 공부하면서, 컨테이너가 무엇인지에
> 대한 궁금증이 생겼으며, [Sigrid Jin' Medium - ServletContainer와 SpringContainer는 무엇이 다른가?
](https://jypthemiracle.medium.com/servletcontainer%EC%99%80-springcontainer%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80-626d27a80fe5)
> 라는 글을 참고하여 정리



## 1. 자바의 메모리 구조

<p align="center">
  <img src="./jvm.PNG"/>
</p>

- JVM은 실행하기 위해서, OS로부터 메모리를 할당 받고, 이것을 나누어 관리한다.
- OS로 부터 받은 메모리 공간을 `Runtime Data Area`라고 하며 JVM은 이 영역을 5개로 나누어 관리한다.
- 용도에 맞게 다음과 같이 다섯개로 나눈다.
  - Class Area(Method Area)
  - Stack Area
  - Heap Area
  - Native Method Stack Area

- 크게는 Class Area, Stack Area, Heap Area로 분류한다.
- PC Register, JVM stack, Native Method stack은 Thread 별로 생성, Heap과 Class Area는
모든 Thread가 공유한다.

**Class Area :**

> 자바 바이트 코드(Java bytecode)란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다.

- 클래스 파일의 바이트 코드가 로드되는 공간이다.
- JVM이 무언가 실행하려면 바이트 코드들이 메모리 공간이 있어야 한다.
- JVM은 메인 메소드를 호출하는 것으로 시작한다.
- 메인메소드에서 사용하는 클래스와 static 변수들이 Class Area(메서드 영역)에 올라온다.
- 즉, Class Area에 로드되는 바이트코드는 프로그램 흐름을 구성하는 바이트코드이다.
- 사실상 전체 바이트코드가 이 영역에 올라간다.
- Class Area에 바이트코드가 로드되는 것을 클래스 로딩이라고 한다.
  - 클래스를 사용하는 시점에 해당 클래스의 바이트코드가 들어있는 파일을 찾아서 메모리에 로딩하는 것을 의미

**JVM 클래스 로딩 절차 :**

- 어떤 메소드를 호출하는 문장을 만났다.
- 그 메소드를 가진 클래스 바이트코드가 아직 로딩된 적이 없다면, JVM은 JRE 라이브러리 폴더에서 클래스를 찾는다.
- 없다면, CLASSPATH 환경변수에 지정된 폴더에서 클래스를 찾는다.
- 찾았다면, 그 클래스 파일에 대해 바이트코드를 검증한다.
- 올바른 바이트코드라면 Class Area로 로딩한다.
- 클래스 변수를 만들라는 명령어가 있다면 Class Area에 그 변수를 준비한다.
- 클래스 블록이 있따면 순서대로 그 블록을 실행한다.
- 이렇게 한번 클래스의 바이트코드가 로딩되면 JVM이 종료될 때까지 유지된다.

---

**Stack Area :**

> 지역변수는 메소드 내에서 선언된 변수, 매개변수는 메소드의 arguments로 넘겨주는 값들로 이해하면 된다.

- 지역변수와 매개변수가 저장되는 공간이다.
- 로컬변수와 매개변수의 특징은 선언된 블록에서만 유효한 값이라는 것이다.
- Stack Area에서는 프로그램의 실행과정에서 임시로 할당되고, 그게 끝나면 소멸되는 것들이 저장된다.

---
**Heap Area :**

- Heap Area에는 흔히 코드에서 new 명령을 통해 생성된 인스턴스 변수가 놓인다.
- 어떤 메소드인지는 상관없이, new 명령으로 만드는 메모리는 힙 영역에 보관된다.
- 힙 영역에 보관되는 메모리는 메서드 호출이 끝나도 사라지지 않고 유지된다.
  - 주소를 잃어버려 가비지 컬렉터에 의해서 지워질 때까지, 혹은 JVM이 종료될 떄 까지 유지

- 인스턴스를 별도의 힙 영역에 할당하는 이유는 인스턴스의 소멸방법과 소멸시점이 지역변수와는 다르기 때문이다.

> 8가지 원시타입(byte, short, long, int, float,double, char, boolean)을 제외한 나머지는 레퍼런스 변수이다.
> 레퍼런스 변수는 실행될 때마다 많은 데이터들을 스택메모리 영역에 뒀다 뺏다 하는게 비효율적이므로, 힙 영역에 그 내용이 저장되고, 스택 영역에는 간단하게 그 주소만 저장된다.
> 힙 영역에는 실제 그 변수가 가리키고 있는 값들이 저장되어 있다.

---

## 2. IoC와 DI

- `제어의 역전(Inversion of Control)` : 제어 반전, 제어의 반전, 역제어는 프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 말한다. 줄여서 IoC(Inversion of Control)이라고 부른다.
- `의존성 주입(dependency injection)` : 소프트웨어 엔지니어링에서 의존성 주입(dependency injection)은 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다.
  -  `의존성`은 예를 들어 서비스로 사용할 수 있는 객체이다. 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말해주는 것이다.
  - `주입`은 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것을 의미한다.
  - 의존성 주입의 의도는 객체의 생성과 사용의 관심을 분리하는 것이다. 이는 가독성과 코드 재사용을 높혀준다.
  - 의존성 주입은 프로그램 디자인이 결합도를 느슨하게 되도록하고 의존관계 역전 원칙과 단일 책임 원칙을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트의 행위로부터 분리하는 것이다.

> IoC는 DI보다 일반적이다. IoC는 호출을 요구하는 대신 다른 코드가 호출할 수 있게 함을 의미한다.
> DI가 없는 IoC의 한 예시로 템플릿 메소드 패턴이 있다. 여기서 다형성은  서브클래싱, 즉 상속을 통해 달성한다.


## 3. Controller 1개가 수십 만개의 요청을 처리하는 방법

- Tomcat은 기본 worker thread가 200개로 설정되어있다.
  - > By default, tomcat sets `maxThread` to 200.

- Tomcat은 하나의 프로세스에서 동작하고, Thread pool(하늘 github 운영체제 정리한 글 참고)을 만든다.
- HttpRequest가 들어오면, 하나씩 쓰레드를 재사용 및 재배정을 진행한다.
- 쓰레드 풀에 생성될 수 있는 쓰레드 개수의 max를 직접 지정할 수 있다. 실질적으로는 유휴한 상태로 남겨지는 쓰레드의 최소 개수도 있다. 요청이 많아지면, 그에 따라 실질적으로 큐에 쌓였다가 쓰레드가 만들어지는 등 일반적인 쓰레드 풀의 동작을 한다.

> 요청 별로 쓰레드가 생성되고, 이에 따라 각각의 ServletContext를 갖는 것은 분명한데, 어떻게 Controller 객체를 공유할 수 있는가?

- Controller 객체 하나를 생성하면 객체 자체는 Heap에 생성된다.
- 하지만 Class의 정보는 Class Area에 저장된다.
- 결국 힙 영역이던 클래스 영역이던 모든 쓰레드가 객체의 Binary Code 정보를 공유할 수 있다.
- 공유되는 정보를 사용하기 위하여 굳이 Controller 객체를 사용하고 있는 쓰레드나 Controller 객체 자체가 Block 될 필요는 없다.
- 내부적으로 상태를 갖는 것이 없으니, 내부의 상태를 변경할 일이 없고 그저 메소드에 대한 정보만 ‘같이 공유해서’ 쓰면 되는 것이기 때문에 동기화에 대한 걱정을 할 필요가 없다.






**ServletContext란? :**
> 서블릿 컨텍스트(ServletContext)란 하나의 서블릿이 서블릿 컨테이너와 통신하기 위해서 사용되어지는 메서드들을 가지고 있는 클래스가 바로 ServletContext다












